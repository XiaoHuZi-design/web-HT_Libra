## C++_learning
[GitHub - AccumulateMore/CPlusPlus: ✔（已完结）最全面的 C++ 笔记 【黑马程序员】](https://github.com/AccumulateMore/CPlusPlus)

[黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1et411b73Z/?share_source=copy_web)



[01常量变量的定义.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676374-bfcaaf4d-845b-4718-85d5-f49604445ef7.txt)[02 sizeof关键字.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676396-62371c12-7ee7-42b6-b678-bf6ffeeea5bf.txt)[03 浮点数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676478-7988b5a4-20b1-466e-a07e-caa5c1aaa071.txt)[04 字符型.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676415-bee667df-2ff4-43c5-bdaf-379b66a428fa.txt)[05 转义字符.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676437-8752e704-dfda-40db-8ab6-f9a9b218fe6b.txt)[06 字符串.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676747-bdad8181-7ecf-40ff-9ed3-48a346ee94ff.txt)[07 布尔类型.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676802-3d31d80c-9747-4e46-8203-40e2587b46fe.txt)[08 数据的输入.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676864-f7a6b2aa-b82c-47c8-a687-f6f3e6942603.txt)[09-1算术运算符_加减乘除.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676894-89ab5e1f-906e-4bf9-9447-78f73e21b57c.txt)[09-2算术运算符_取模运算.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698676972-dfd4ef85-abf6-4608-8bef-29d1444e01e2.txt)[09-3算术运算符_递增递减运算.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677113-9840b5f5-86df-42a1-991a-8ff140c5378e.txt)[09-4算术运算符_赋值运算.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677190-dd832260-43ca-4d94-be25-fac3795edeb9.txt)[09-5算术运算符_比较运算符.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677261-32fb7191-2035-434c-a5f4-da05137e9c08.txt)[09-6算术运算符_逻辑运算_非.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677309-8cae558e-acb7-4211-9bbe-7b1afc3946eb.txt)[09-7算术运算符_逻辑运算_与.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677428-2f4607f0-6905-45d8-97e2-c3a73e1fbddb.txt)[09-8算术运算符_逻辑运算_或.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677563-cd10bc04-883c-4003-adbd-7a0f22200b57.txt)[10-1流程结构_选择结构_单行if.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677589-e0dd30d3-3e8b-43a9-a2ec-d7dd6acdd0c4.txt)[10-2流程结构_选择结构_多行if.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677742-f027dfa1-5df7-4835-8d45-1a6527a217c1.txt)[10-3流程结构_选择结构_多条件if.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677723-d87f39a8-be9e-4bb4-abf1-c89675452f41.txt)[10-4流程结构_选择结构_嵌套if.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677853-3967307e-86bc-4a98-9787-668fa34d35b1.txt)[10-5流程结构_选择结构_三小猪案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677947-ba525860-b9fd-4a1e-947d-d5417e39b84a.txt)[10-6流程结构_选择结构_三目运算符.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698677988-4c5cc442-3587-4d28-99ec-e1e80de1c080.txt)[10-7流程结构_选择结构_Switch语句.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678137-fefb6c90-98de-4ad4-9d9c-04efac4e7a41.txt)[11-1循环结构_while语句.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678136-8a8768a3-b8da-4588-ac88-54ec9321c004.txt)[11-2循环结构_猜数字案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678265-207e5425-74aa-4cce-b0e9-a50640f9801d.txt)[11-3循环结构_dowhile语句.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678322-79b16b0e-ddcf-4861-937f-65dbaa19589d.txt)[11-4循环结构_水仙花数案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678382-75b46241-092c-4d49-88c9-2b85c3ce3d5b.txt)[11-5循环结构_for循环.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678562-2f625ca6-d13a-40f4-b5fb-7efa2618739d.txt)[11-6循环结构·_敲桌子案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678533-849ef679-dd76-4621-b433-0a351cd19a17.txt)[11-7循环结构_嵌套循环案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678665-0beaf2ed-3531-4f9a-a6eb-b9d7fc3d5f9a.txt)[11-8循环结构_九九乘法表案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678711-933a4825-cda5-473b-b661-62e1fd650a7e.txt)[12-1跳转语句_break语句.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678772-4816b149-0f0d-4c9c-8a9b-fc37a79d799d.txt)[12-2跳转语句_continue语句.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678924-d0f8bc7f-31a0-4f0b-9dfb-139702fb5257.txt)[12-3跳转语句_goto语句.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698678995-db5af24b-6de1-4949-97da-37cfdc41205c.txt)[13-1数组_一维数组定义方式.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679064-a3f959b6-dab3-427d-bc85-d076cd4589b9.txt)[13-2数组_一维数组数组名.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679110-7fdaca89-b4a4-4939-87ce-5ef43a176ded.txt)[13-3数组_五只小猪称体重.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679191-74d949f0-ecf2-4087-be48-267942d44e33.txt)[13-4数组_元素逆置.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679331-219cb683-5d27-423e-a77a-22d7011cb9fd.txt)[13-5数组_冒泡排序.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679402-89774176-96ff-4c0a-87cf-2f894fd870c6.txt)[13-6数组_二维数组定义方式.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679445-3676c15f-7a32-498d-9084-41a67578cfad.txt)[13-7数组_二维数组数组名.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679512-06bbf5b8-be8f-4166-9be8-3e92bfc0ae6f.txt)[13-8数组_考试成绩统计案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679634-1725f003-efeb-45bf-9853-82f46c3b4c6b.txt)[14-1函数_函数的定义与调用.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679700-2101a395-bd70-4ee0-a148-e040bc6aaf54.txt)[14-2函数_值传递.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679847-f136adcf-5df6-4149-acc7-3dd675035286.txt)[14-3函数_常见的样式.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679875-206b0cd6-ecc9-47ec-a7f2-0b68bc107729.txt)[14-4函数_函数的声明.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698679939-c6737c21-a224-4f66-9bfa-bce1dd0daf7f.txt)[14-5函数_函数的分文件编写.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680007-8bf4f270-2a3c-446c-9f3b-1bd61e5213e6.txt)[15-1指针-定义和使用.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680107-61c367b6-5155-460f-8a44-7d215ce3871e.txt)[15-2指针-所占内存空间.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680197-2936e9bf-89a4-40a7-8932-72568b36f656.txt)[15-3指针-空指针.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680259-bfac7c4f-d889-4973-8528-f8ead642d05a.txt)[15-4指针-野指针.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680326-42941306-6699-4cbd-aac7-c9d92297a8ed.txt)[15-5指针-const修饰指针.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680415-1c4be3a6-1659-4ac9-9131-023b32aabca3.txt)[15-6指针-指针和数组.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680469-4a0d3bf0-99a5-4ed2-9e95-a28759fffb0c.txt)[15-7指针-指针和函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680621-f4ac99a8-c2f4-477f-898c-87ccad0bd9a6.txt)[15-8指针-指针数组函数案例.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680630-e8714601-13eb-4a08-8ce6-3b24616d1e2f.txt)[16-1结构体-定义和使用.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680732-9aee6936-b4f8-4b95-be97-66dc45313603.txt)[16-2结构体-结构体数组.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680811-799ddc28-ec6c-4625-84c4-3df87f140a96.txt)[16-3结构体-结构体指针.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698680971-08c33b9b-00dd-4176-8cb9-ee0b092f0198.txt)[16-4结构体-结构体嵌套结构体.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681048-751914f9-cadd-4620-84af-eacb9f017c02.txt)[16-5结构体-结构体作函数参数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681089-5f615de5-f1ad-4b94-84f2-e7a75960e8be.txt)[16-6结构体-结构体中const使用场景.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681147-21a50a69-0bd6-42db-9ab1-54f836da3edf.txt)[16-7结构体-结构体案例1.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681234-576b06be-664b-4bbd-b04a-8420084b00ba.txt)[16-8结构体-结构体案例2.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681474-e51991bd-1865-438f-93fe-4eded09a689d.txt)[17通讯录管理系统.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681454-a2ee0ce7-a0fe-4df8-a734-abab658eaac9.txt)[18-1内存四区-全局区.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681507-a1ac663d-8705-4284-ad82-86d07360ce74.txt)[18-2内存四区-栈区.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681517-9f5c8015-fdb1-40b8-be10-81d3224549a2.txt)[18-3内存四区-堆区.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681627-127af542-4a93-445f-b42a-0083c329e03a.txt)[18-4new操作符.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681871-2da27391-3dca-4992-8924-6a6590595ff7.txt)[19-1引用-基本语法.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681936-eb3bdd8c-486b-4288-918b-6378515859d5.txt)[19-2引用-注意事项.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698681944-0c36693e-f68d-42bc-a50f-7b52abfd5ebf.txt)[19-3引用-做函数参数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682030-77dc0fe9-49f8-47d9-a0a3-4dbfcb9520dd.txt)[19-4引用-做函数返回值.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682076-453fdc4d-ef4e-4314-9d1e-f57487fe966b.txt)[19-5引用-本质.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682302-44672233-1213-4491-8f65-34551f4d5365.txt)[19-6引用-常量引用.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682333-40af95d6-95b4-4106-b2b7-ce8bf67b9222.txt)[20-1函数高级-函数默认参数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682334-262c102e-6137-4d99-98be-72b97c3ba9de.txt)[20-2函数高级-占位参数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682403-7f3f8baa-6a22-4fe0-8cdd-a400773ac26f.txt)[20-3函数高级-函数重载基本语法.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682491-af7ff982-d338-4a1b-bf03-173240bda1d0.txt)[20-4函数高级-函数重载注意事项.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682719-3a77d53c-153f-4403-a2be-bba262777f89.txt)[21-1封装-属性和行为作为整体.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682760-ad939408-7e77-4998-b249-e0aa80c336cd.txt)[21-2封装案例-设计学生类.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682748-83c491c4-1b78-45e1-b187-e16edc22cb20.txt)[21-3封装-访问权限.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682803-a5b27228-f701-49d5-8f97-6e1bbd7d7d6a.txt)[21-4封装-struct与class区别.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698682866-f79ba766-0554-46f2-8990-ebe77da167e0.txt)[21-5封装-成员属性私有化.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683179-6b8ae37c-5edc-4705-98e5-90c34df7cf53.txt)[21-6封装案例-立方体类.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683232-e9b0e71f-c35b-4261-be0a-921e450ead35.txt)[21-7.1导入其他的类.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683349-c183f134-4600-41ae-bd75-b2f2bf429931.txt)[21-7封装案例-点和圆关系.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683328-afbeb870-884a-40e9-a718-4cc02dd19852.txt)[22-1类中特性-构造函数和析构函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683342-550ebb9f-6a49-4d2f-838c-034926c498f5.txt)[22-2类中特性-构造函数的分类及调用.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683582-a2f30d12-7302-4d06-b3f2-1725fa4dcc88.txt)[22-3类中特性-拷贝构造函数调用时机.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683640-31806942-bd7a-498a-a5ff-15961718e4bd.txt)[22-5调用定义的拷贝构造函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683752-b2d257a2-7c19-4aee-9da4-cc6c64c65e70.txt)[22-6调用默认的拷贝构造函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683747-8c3d8c53-f663-4e04-8478-4fcea3653db4.txt)[22-7调用定义的有参构造函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683743-64e0dc07-89c1-4b87-816c-8854376eb26e.txt)[22-8调用定义的拷贝构造函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698683971-d0fe7236-9df5-4d7a-a6b5-5b671cf3ee88.txt)[22-9类中特性-深拷贝与浅拷贝.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684064-c709fbd7-d84a-4b2d-a966-8def426ec09d.txt)[22-11传统初始化操作.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684184-d6279353-f5ba-4d90-bc91-a6275ded51c2.txt)[22-12灵活初始化操作.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684206-2039426d-50ed-4bfb-b354-12fc03ee6490.txt)[22-13类中特性-类对象作为类成员.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684200-fc485da6-1f9d-4d0b-8dc1-6e5fb8731ecc.txt)[22-14静态成员.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684351-5153dd0e-d073-4dd5-9053-4d2e59c0af40.txt)[22-15静态成员函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684430-80b93432-fe39-4cee-aec7-3814b4630ea0.txt)[22-16成员变量和成员函数分开存储.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684585-8ff56eef-aa3a-4c26-90bd-804694c49adb.txt)[22-17类中特性-this指针概念.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684598-7b470966-25f9-4501-b39b-9944e0496a37.txt)[22-18空指针访问成员函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684598-8d16b066-d13a-458d-9f60-ff374ab0e29a.txt)[22-19const修饰成员函数.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684813-71e2ebc6-fbb7-4eb7-a8f8-756d891c43ac.txt)[23-1友元-全局函数做友元.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698684824-48198bbc-6fed-4921-89b3-13170f594c79.txt)[23-2友元-类做友元.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685034-fa3f63da-63e9-4c88-8b47-24e7ad8366fe.txt)[23-3友元-成员函数做友元.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685071-198fde2f-f012-442a-8733-5c2b230b4658.txt)[24-1加号运算符重载.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685065-dea2e8d0-53eb-4b48-b915-41ab5a9815a0.txt)[24-2左移运算符重载.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685195-b41fa129-29b7-4cf1-88c3-3a8ba6d3209c.txt)[24-3递增运算符重载.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685207-1846753b-9588-4c43-9556-40b1af9cd0eb.txt)[24-4赋值运算符重载.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685468-1693f3c4-225e-431c-883f-d6323f63be4d.txt)[24-5关系运算符重载.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685463-e3b032c4-2d16-469a-b835-94727a6a46bf.txt)[24-6函数调用运算符重载.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685476-23b67b73-facd-427f-8b5e-41b1f00f0b1c.txt)[25-1类中继承-基本语法.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685579-f2ca02bb-202b-4507-8d2e-bb614a66abae.txt)[25-2类中继承-继承方式.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685614-0468ad05-c460-45c8-b37e-ecbdeac803cb.txt)[25-3类中继承-继承中的对象模型.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685833-08e02ee2-eb45-4e63-a199-c6024c3fdd4f.txt)[25-4类中继承-构造和析构顺序.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685877-0261aa57-085e-45e4-8182-4e8c84519cdb.txt)[25-5类中继承-同名成员处理.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685890-9ebb6853-92e6-4e09-a953-f6a30dc91a64.txt)[25-6类中继承-同名静态成员处理.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698685931-1712880e-6705-4bda-84bb-044a74892be7.txt)[25-7类中继承-多继承语法.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686018-7a38643d-5218-4edb-b6b2-0b14f2f095c1.txt)[25-8菱形继承.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686219-2cbbb4ae-08f1-4c7c-96f7-a58dd0362d60.txt)[25-9菱形继承虚继承方式.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686310-7791db3b-5ce0-4de8-a207-0538e1090d81.txt)[26-1多态-基本语法.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686314-3ed2e257-ced6-4a0a-84b2-a3b00421931a.txt)[26-2多态-动态多态.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686364-8e2abcd2-3fb5-4a5c-9b29-99ebc3a19230.txt)[26-3多态案例-计算器.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686437-2b831ab9-37ae-4009-9f8e-31f611eda586.txt)[26-4多态-纯虚函数和抽象类.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686630-95d12a8b-c9de-43c7-9993-b71ba632b020.txt)[26-5多态-虚析构和纯虚析构.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686704-f5d5509c-06b7-48bc-9a63-c0ae299245ce.txt)[26-6多态案例-制作饮品.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686744-2f205f60-5e61-48a1-b22d-c5ec1fc8b0ab.txt)[circle.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698686737-f5485b91-ab6e-4974-aa57-046f66db0d92.txt)[CppProperties.json](https://www.yuque.com/attachments/yuque/0/2024/json/39216292/1725698686864-8dba303d-2e43-4a48-a968-78a6e32846c3.json)[point.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698687008-7efab879-7723-4d16-ad23-987b29353d44.txt)



[01全局区.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698944321-29990750-98ab-4a72-8c45-72d5feb3fdd8.txt)[02栈区.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698944369-43823907-7b49-439d-a4db-169da62f1754.txt)[03堆区.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698944423-92013afe-83b6-4254-9c85-fb02ecf6afde.txt)[04new操作符.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698944427-1fc05a77-79f8-4f37-92bc-a85312715d77.txt)



[ticketMachine.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699016244-63929c93-4c07-4ff3-a677-b251b0e146a8.txt)[自动售卖机.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725698976473-a429e9ab-fe55-4b3b-8557-c26ea790b51e.txt)

[机房预约系统.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699094218-9be32b15-5ff2-4aa0-b716-6f080df766b0.txt)[admin.txt](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699073765-c1384033-ff3c-4bc4-8497-638f899fbb22.txt)[computerRoom.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074045-c3004f4b-76e8-4155-add3-38dff85090a7.txt)[computerRoom.txt](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699073893-a465effa-cebe-4808-ab79-2ef51ab5d650.txt)[globalFile.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074042-45265a54-048a-4ead-8e34-c91b63277e7a.txt)[Identity.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074040-cd004013-7207-4948-aee8-a42192777bc1.txt)[manager.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074115-afcb4d06-2cc6-4ac2-97d6-c89daf9b8dc5.txt)[manager.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074298-6243f8f8-9993-4795-9108-1cee1be9a870.txt)[order.txt](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074454-d0685f2e-8785-4554-9c10-d01d084162ab.txt)[orderFile.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074489-480e0819-fb18-472e-8118-788a7c4daeeb.txt)[orderFile.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074496-554755b7-485b-43cf-af08-dd37de87302e.txt)[student.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074484-aea3a067-af4e-435f-8823-3d33cf7a6b73.txt)[student.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074768-1564098b-50d0-4384-81e2-084d9ff05475.txt)[student.txt](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074809-f2ae355b-3bb3-4322-93ef-c78b90cf2624.txt)[teacher.cpp](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074905-33c8094f-c194-4421-835a-e5b523c5e558.txt)[teacher.h](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074924-4c0f3f5c-2428-4a31-9aa7-1567025db70f.txt)[teacher.txt](https://www.yuque.com/attachments/yuque/0/2024/txt/39216292/1725699074808-8dad25c8-87f3-40ae-a3dd-3f691a4d5d0c.txt)



```cpp
冒泡排序：

void bubbleSort(int arr[], int n) {  
    for (int i = 0; i < n - 1; i++) {  
        for (int j = 0; j < n - i - 1; j++) {  
            if (arr[j] > arr[j + 1]) {  
                // 交换arr[j]和arr[j+1]的位置  
                int temp = arr[j];  
                arr[j] = arr[j + 1];  
                arr[j + 1] = temp;  
            }  
        }  
    }  
}

冒泡排序的基本思想是通过相邻元素之间的比较和交换来把待排序的序列排成有序序列。
第一次遍历，将最大的元素放在最后面；
第二次遍历，将次大的元素放在倒数第二个位置；
以此类推，直到将最小的元素放在最前面。


快速排序：

void quickSort(int arr[], int left, int right) {  
    if (left >= right) {  
        return;  
    }  
    int pivot = arr[left];  
    int i = left + 1;  
    int j = right;  
    while (i <= j) {  
        if (arr[i] < pivot && arr[j] > pivot) {  
            // 交换arr[i]和arr[j]的位置  
            int temp = arr[i];  
            arr[i] = arr[j];  
            arr[j] = temp;  
            i++;  
            j--;  
        } else if (arr[i] >= pivot) {  
            i++;  
        } else if (arr[j] <= pivot) {  
            j--;  
        }  
    }  
    // 将pivot放到正确的位置上  
    int temp = arr[left];  
    arr[left] = arr[j];  
    arr[j] = temp;  
    // 递归处理左右两部分  
    quickSort(arr, left, j - 1);  
    quickSort(arr, j + 1, right);  
}

快速排序的基本思想是通过选取一个基准元素将待排序的序列分成两部分，
其中一部分的所有元素都比基准元素小，另一部分的所有元素都比基准元素大，
然后对这两部分分别进行递归排序，直到将整个序列排成有序序列。

```

## 经典排序算法
[十大经典排序算法（C++实现） - fengMisaka - 博客园 (cnblogs.com)](https://www.cnblogs.com/linuxAndMcu/p/10201215.html)

### 1.冒泡排序
<font style="color:rgb(79, 79, 79);">算法步骤</font>

<font style="color:rgb(77, 77, 77);">1.比较相邻的元素。如果第一个元素比第二个元素大，就交换他们两个。  
</font><font style="color:rgb(77, 77, 77);">2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。  
</font><font style="color:rgb(77, 77, 77);">3.针对所有的元素重复以上的步骤，除了最后一个。  
</font><font style="color:rgb(77, 77, 77);">4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</font>

```plain
#include <bits/stdc++.h>
using namespace std;

int n;
int a[1000];

template <typename T>
//整数或浮点数皆可使用
void bubble_sort(T a[],int len) {
    for(int i=0; i<len-1; i++)
        for(int j=0; j<len-1-i; j++)
        	if(a[j]>a[j+1]) swap(a[j],a[j+1]);
}

int main() {
	scanf("%d",&n);
	for(int i=0; i<n; i++) scanf("%d",&a[i]);
	bubble_sort(a,n);
	for(int i=0; i<n; i++) printf("%d ",a[i]);
	printf("\n");
    return 0;
}

```

### 2.快速排序
<font style="color:rgb(79, 79, 79);">算法步骤</font>

<font style="color:rgb(77, 77, 77);">1.从数列中挑出一个元素，称为 “基准”（pivot）;  
</font><font style="color:rgb(77, 77, 77);">2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；  
</font><font style="color:rgb(77, 77, 77);">3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</font>

```plain
#include <bits/stdc++.h>
using namespace std;

int n;
int a[1000];

void qsort(int a[],int l,int r) {
	if(l>=r) return; //如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了
	int i=l,j=r;
	int x=a[l];
	while(i<j) {    /*控制在当组内寻找一遍*/
		while(i<j && x<=a[j]) j--;/*向前寻找*/
        /*而寻找结束的条件就是:
        1.找到一个小于或者大于key的数（大于或小于取决于你想升序还是降序）
        2.没有符合条件1的，并且i与j的大小没有反转*/ 
		a[i]=a[j];
        //找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是 a[l]，那么就是给x）
		while(i<j && x>=a[i]) i++;
        /*这是i在当组内向前寻找，同上，不过注意与x的大小关系停止循环和上面相反，
        因为排序思想是把数往两边扔，所以左右两边的数大小与x的关系相反*/
		a[j]=a[i];
	}
	a[i]=x; //当在当组内找完一遍以后就把中间数key回归
	qsort(a,l,i-1); //最后用同样的方式对分出来的左边的小组进行同上的做法
    qsort(a,i+1,r); //用同样的方式对分出来的右边的小组进行同上的做法
    //当然最后可能会出现很多分左右，直到每一组的 i=j 为止
}

int main() {
	scanf("%d",&n);
	for(int i=0; i<n; i++) scanf("%d",&a[i]);
	qsort(a,0,n-1);
	for(int i=0; i<n; i++) printf("%d ",a[i]);
	printf("\n");
    return 0;
}


```

```plain
#include <bits/stdc++.h>
using namespace std;

int n;
int a[1000];

void qsort(int a[],int l,int r){
    if(l>=r) return;
    int i=l,j=r+1;
    int x=a[l];
    while(1) {
        //从左向右找比x大的值
        while(a[++i]<x)
            if(i==r) break;
        //从右向左找比x小的值
        while(a[--j]>x)
            if(j==l) break;
        if(i>=j) break;
        //交换i,j对应的值
        swap(a[i],a[j]);
    }
    //中枢值与j对应值交换
    swap(a[l],a[j]);
    qsort(a,l,j-1);
    qsort(a,j+1,r);
}

int main() {
	scanf("%d",&n);
	for(int i=0; i<n; i++) scanf("%d",&a[i]);
	qsort(a,0,n-1);
	for(int i=0; i<n; i++) printf("%d ",a[i]);
	printf("\n");
    return 0;
}


```

### 3.选择排序
<font style="color:rgb(77, 77, 77);background-color:rgb(250, 250, 250);">1.在未排序序列中找到最小（大）元素，存放到排序序列的起始位置;</font>

<font style="color:rgb(77, 77, 77);background-color:rgb(250, 250, 250);">2.在剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾;</font>

<font style="color:rgb(77, 77, 77);background-color:rgb(250, 250, 250);">3.重复步骤 2，直到所有元素排序完毕。</font>

```plain
void selectSort(int* arr, int n)
{
	int minIndex = 0;
	int temp;

	for (int i = 0; i < n - 1; i++) // 排序n-1次
	{
		minIndex = i; // minIndex设置为每轮未排序序列的第一个位置

		for (int j = i + 1; j < n; j++)
		{
			// 每轮中最小的值索引，赋值给minIndex
			if (arr[j] < arr[minIndex])
			{
				minIndex = j;
			}
		}

		// 将每轮中最小的值与每轮中第一个位置(i)的值进行交换
		if (minIndex != i) // 如果这轮中最小的值刚好在第一个位置，就不用交换了
		{
			temp = arr[minIndex];
			arr[minIndex] = arr[i];
			arr[i] = temp;
		}
	}
}

```

### 4.插入排序
<font style="color:rgb(79, 79, 79);">算法步骤</font>

<font style="color:rgb(77, 77, 77);">将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</font>

<font style="color:rgb(77, 77, 77);">从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面，保持相应顺序不变，插入排序是一个稳定的排序算法。）</font>

```plain
void insertSort(int arr[], int n) {
	int i, j, temp;
	for (i = 1; i < n; i++) {
		temp = arr[i];

		for (j = i; j > 0 && arr[j - 1] > temp; j--)
			arr[j] = arr[j - 1]; // 把已排序元素逐步向后挪位

		arr[j] = temp; // 插入
	}
}
            
```

### 5.其他
[十大经典排序算法（C++实现） - fengMisaka - 博客园 (cnblogs.com)](https://www.cnblogs.com/linuxAndMcu/p/10201215.html)

[排序算法 —— 希尔排序（图文超详细）-CSDN博客](https://blog.csdn.net/m0_63033419/article/details/127524644)

## 数组、指针、结构体
### 1.数组






### 2.指针






### 3.结构体






## 面向对象（封装、继承、多态）
```plain
C++的面向对象
1. 面向对象三大特性

① C++面向对象的三大特性为：封装、继承、多态。

② C++认为万事万物皆为对象，对象上有其属性和行为。

③ 例如：

1、人可以作为对象，属性有姓名、年龄、身高、体重......行为有走、跑、跳、吃饭、唱歌......
2、车也可以作为对象，属性有轮胎、方向盘、车灯......行为有载人、放音乐、放空调......
3、具有相同新值的对象，可以抽象为类，人属于人类，车属于车类。
```

### 1.封装
```cpp
#include <iostream>
using namespace std;

//① 封装是C++面向对象三大特性之一。
//② 封装的意义一：
//1、将属性和行为作为一个整体，表现生活中的事物。
//2、将属性和行为加以权限控制。

const double PI = 3.14;

//设计一个圆类，求圆的周长
//圆求周长的公式： 2 * PI * 半径

//class 代表设计一个类，类后面紧跟着的就是类名称
class Circle
{
    //访问权限
    //公共权限
    public:   //是冒号，不是分号

    //属性
    //半径
    int m_r;

    //行为
    //获取圆的周长
    double calculateZC()
    {
        return 2 * PI * m_r;
    }
};

int main()
{
    //通过圆类 创建具体的圆(对象)
    //实例化 （通过一个类 创建一个对象的过程）
    Circle c1;
    //给圆对象  的属性进行赋值
    c1.m_r = 10;

    // 2 * PI * 10 = 62.8
    cout << "圆的周长为：" << c1.calculateZC() << endl;

    system("pause");
    
    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708961303-6f424124-bd71-447d-a9d1-f4fe6a70ec42.png)

```cpp
#include<iostream>
using namespace std;
#include<string>

//设计一个学生类，属性有姓名和学号
//可以给姓名和学号赋值，可以显示学生的姓名和学号

//设计学生类
class Student
{
public:  //公共权限

    //类中的属性和行为  我们统一称为 成员
    //属性 也叫 成员属性 成员变量
    //行为 也叫 成员函数 成员方法

    //属性
    string m_Name;
    int m_Id;

    //行为
    //显示姓名和学号
    void showStudent()
    {
        cout << "姓名：" << m_Name << "  学号:" << m_Id << endl;
    }

    //给姓名赋值
    void setName(string name){
        m_Name = name;
    }

    //给学号赋值
    void setId(int id){
        m_Id = id;
    }
};

int main(){

    //创建一个具体学生  实例化对象
    Student s1;
    //给s1对象、进行属性赋值操作
    //s1.m_Name = "张三";
    s1.setName("张三");
    //s1.m_Id = 1;
    s1.setId(1);

    //显示学生信息
    s1.showStudent();

    Student s2;
    s2.m_Name = "李四";
    s2.m_Id = 2;
    s2.showStudent();

    system("pause");
    return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725709034337-7f13c458-d1fb-41a6-9dc4-51a5a227267c.png)

```cpp
#include <iostream>
using namespace std;

//① 类在设计时，可以把属性和行为放在不同的权限下，加以控制。
//② 封装的意义二：
//1、public 公共权限
//2、protected 保护权限
//3、private 私有权限


//访问权限
//三种
//公共权限 public     类内可以访问成员 类外可以访问成员
//保护权限 protected  类内可以访问成员 类外不可以访问成员 子类可以访问父类中的保护内容
//私有权限 private    类内可以访问权限 类外不可以访问成员 子类不可以访问父类中的私有内容

class Person
{
//公共权限
public:   
    string m_Name;  //姓名

protected:
    string m_Car;  //汽车

private:
    int m_Password; //银行卡密码

public:
    void func()
    {
        m_Name = "李四";
        m_Car = "奔驰";  //保护权限内容，在类外访问不到
        m_Password = 123;
    }
};

int main()
{
    //实例化具体对象
    Person p1;
    p1.m_Name = "李四";
    p1.m_Car = "奔驰";  //保护权限内容，在类外访问不到
    p1.m_Password = 123; //私有权限内容，在类外访问不到

    p1.func();  //公共权限内容，在类可以访问

    system("pause");

    return 0;

}
```

<font style="color:#DF2A3F;">报错！私有权限，不能访问</font>

```cpp
#include <iostream>
using namespace std;

//① 在C++中struct和class唯一的区别就在于默认的访问权限不同。
//② 区别：
//1、struct 默认权限为公共。
//2、class 默认权限为私有。


//访问权限
//三种
//公共权限 public     类内可以访问成员 类外可以访问成员
//保护权限 protected  类内可以访问成员 类外不可以访问成员 子类可以访问父类中的保护内容
//私有权限 private    类内可以访问权限 类外不可以访问成员 子类不可以访问父类中的私有内容

class C1
{
    int m_A;  // 默认权限是私有
};

struct C2
{
    int m_A; //默认权限 是公共
};

int main()
{
    //struct 和 class 区别
    //struct 默认权限是 公共 public
    //class  默认权限是 私有 private
    C1 c1;
    c1.m_A = 100;  //私有权限，不能访问

    C2 c2;
    c2.m_A = 100;   //公共权限，可以访问

    system("pause");
    
    return 0;

}
```

<font style="color:#DF2A3F;">报错！私有权限，不能访问</font>

```cpp
#include <iostream>
using namespace std;
#include <string>

//成员属性设置为私有
//1、可以自己控制读写权限
//2、对于写可以检测数据的有效性

class Person
{
public:
    //设置姓名
    void setName(string name)
    {
        m_Name = name;
    }
    //获取姓名
    string getName()
    {
        return m_Name;
    }

    //获取年龄 可读可写 
    int getAge()
    {
        return m_Age;
    }

    //设置年龄 如果想修改（年龄的范围必须是0~150之间）
    void setAge(int age)
    {
        if (age < 0 || age>150)
        {
            m_Age = 0; //强制改为0
            cout << "你这个老妖精！" << endl;
            return; //强制退出
        }
        m_Age = age;
    }

    void setLover(string lover)
    {
        m_Lover = lover;
    }

private:
    //姓名 可读可写
    string m_Name;
    //年龄 只读
    int m_Age;
    //情人 只写
    string m_Lover;
};

int main()
{
    Person p;
    p.setName("张三");

    cout << "姓名为：" << p.getName() << endl;


    //p.m_Age = 18;  //私有权限，不可以类外改
    p.setAge(1000);  
    cout << "年龄为：" << p.getAge() << endl;

    //设置情人为苍井女士
    p.setLover("小李");  //有这个函数可以设置
    //cout << "情人为：" << p.getLover() << endl;  //没有这个函数，不能获得

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725709297672-4a38e64f-e0b5-4142-a7da-47bdbc409394.png)

```cpp
#include<iostream>
using namespace std;

//立方体类设计
//1、创建立方体类
//2、设计属性
//3、设计行为 获取立方体面积和体积
//4、分别利用全局函数和成员函数 判断两个立方体是否相等

class Cube
{
public:
    //行为
    //设置长
    void setL(int l)
    {
        m_L = l;
    }
    //获取长
    int getL()
    {
        return m_L;
    }
    //设置宽
    void setW(int w)
    {
        m_W = w;
    }
    //获取宽
    int getW()
    {
        return m_W;
    }   
    //设置高
    void setH(int h)
    {
        m_H = h;
    }
    //获取高
    int getH()
    {
        return m_H;
    }   
    //获取立方体面积
    int calculateS()
    {
        return 2*m_L*m_W + 2*m_L*m_H + 2*m_W*m_H;
    }
    //获取立方体体积
    int calculateV()
    {
        return m_L*m_W*m_H;
    }

    //利用成员函数判断两个立方体是否相等
    bool isSamebyclass(Cube &c)
    {
        if(m_L==c.getL() && m_W == c.getW() && m_H==c.getH())
        {
            return true;
        }
        return false;
    }   

private:
    //属性
    int m_L; //长
    int m_W; //宽
    int m_H; //高
};

//利用全局函数判断两个立方体是否相等
bool issame(Cube &c1, Cube &c2)
{
    if(c1.getL()==c2.getL() && c1.getW()==c2.getW() && c1.getH()==c2.getH())
    {
        return true;
    }
    else
    {
        return false;
    }
}

int main(){

    //创建立方体对象
    Cube c1;
    c1.setL(10);
    c1.setW(10);
    c1.setH(10);

    cout << "c1的面积为:" << c1.calculateS() << endl;
    cout << "c1的体积为:" << c1.calculateV() << endl;

    //创建第2个立方体
    Cube c2;
    c2.setL(10);
    c2.setW(10);
    c2.setH(10);

    //利用全局函数判断是否相等
    bool set = issame(c1,c2);
    if(set)
    {
        cout << "c1和c2是相等的" << endl;
    }
    else
    {
        cout << "c1和c2是不相等的" << endl;
    }
    
    //利用成员函数判断是否相等
    bool ret = c1.isSamebyclass(c2);
    if(ret)
    {
        cout << "成员函数判断:c1和c2是相等的" << endl;
    }
    else
    {
        cout << "成员函数判断:c1和c2是不相等的" << endl;
    }

    system("pause");
    return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725709395005-e9a09858-af49-4b21-847c-5b6a0579ba64.png)

```cpp
#include <iostream>
using namespace std;

//点和圆关系案例

//点类
class Point
{
public:
    //设置x
    void setX(int x)
    {
        m_X = x;
    }
    //获取x
    int getX()
    {
        return m_X;
    }
    //设置y
    void setY(int y)
    {
        m_Y = y;
    }
    //获取y
    int getY()
    {
        return m_Y;
    }

private:
    int m_X;
    int m_Y;
};

//圆类
class Circle
{
public:
    //设置半径
    void setR(int r)
    {
        m_R = r;
    }
    //获取半径
    int getR()
    {
        return m_R;
    }
    //设置圆心
    void setCenter(Point center)
    {
        m_Center = center;
    }
    //获取圆心
    Point getCenter()
    {
        return m_Center;
    }
private:
    int m_R; //半径
    Point m_Center; //圆心   //在类中可以让另一个类 作为本类中的成员
};

//判断点和圆关系
void isInCircle(Circle& c, Point& p)
{
    //计算两点之间距离 平方
    int distance =
        (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
        (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());   //c.getCenter()返回的是圆心点center类
                                                                                 //可以调用圆心点center类中的方法

    //计算半径的平方
    int rDistance = c.getR() * c.getR();

    //判断关系
    if (distance == rDistance)
    {
        cout << "点在圆上" << endl;
    }
    else if (distance > rDistance)
    {
        cout << "点在圆外" << endl;
    }
    else
    {
        cout << "点在圆内" << endl;
    }
}

int main()
{
    //创建圆
    Circle c;
    c.setR(10);
    Point center;
    center.setX(10);       //设置点的横坐标
    center.setY(0);        //设置点的纵坐标
    c.setCenter(center);   //设置点类传入圆类

    //创建点
    Point p;
    p.setX(10);
    p.setY(10);

    //判断关系
    isInCircle(c, p);

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725709455638-68190370-f38a-4b59-9e9f-ba53cf0981c9.png)

```cpp
//这个是主文件 .cpp文件

#include <iostream>
using namespace std;
#include "circle.h" //想用点类，就要包含点类的头文件
#include "point.h"  //想用圆类，就要包含点类的头文件


//判断点和圆关系
void isInCircle(Circle& c, Point& p)
{
    //计算两点之间距离 平方
    int distance =
        (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
        (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());   //c.getCenter()返回的是圆心点center类
                                                                                 //可以调用圆心点center类中的方法

    //计算半径的平方
    int rDistance = c.getR() * c.getR();

    //判断关系
    if (distance == rDistance)
    {
        cout << "点在圆上" << endl;
    }
    else if (distance > rDistance)
    {
        cout << "点在圆外" << endl;
    }
    else
    {
        cout << "点在圆内" << endl;
    }
}

int main()
{
    //创建圆
    Circle c;
    c.setR(10);
    Point center;
    center.setX(10);       //设置点的横坐标
    center.setY(0);        //设置点的纵坐标
    c.setCenter(center);   //设置点类传入圆类

    //创建点
    Point p;
    p.setX(10);
    p.setY(10);
    
    //判断关系
    isInCircle(c, p);

    system("pause");

    return 0;

}
```

```cpp
#pragma once 
#include <iostream>  //标准输出流
using namespace std; //标准命名空间
#include "Point.h"  //一个类中用到另一个类，把另一个类包含的头文件包含进来

//圆类
class Circle
{
public:
    //设置半径
    void setR(int r);

    //获取半径
    int getR();

    //设置圆心
    void setCenter(Point center);

    //获取圆心
    Point getCenter();

private:
    int m_R; //半径
    Point m_Center; //圆心   //在类中可以让另一个类 作为本类中的成员
};
```

```cpp
//这是point.h头文件

#pragma once //防止头文件重复包含，防止头文件冲突
#include <iostream> //标准输入输出
using namespace std; //标准命名空间

//只要函数声明、变量声明
//成员函数只需要声明就好了，末尾有分号。
class Point
{
public:
    //设置x
    void setX(int x);

    //获取x
    int getX();

    //设置y
    void setY(int y);

    //获取y
    int getY();


private:
    int m_X;
    int m_Y;
};
```

### 1.2.构造函数与析构函数
```cpp
#include <iostream>
using namespace std;
#include <string>

//对象的初始化和清理

class Person
{
public:  //无论是构造函数还是析构函数都是在public作用域下
    //1、构造函数 进行初始化操作
    //没有返回值 不用写void
    //函数名 与类名相同
    //构造函数可以有参数，可以发生重载
    //创建对象的时候，构造函数会自动调用，而且只调用一次
    Person()
    {
        cout << "Person 构造函数的调用" << endl;
    }

    /*
    如果你不写，编译器会自动创建一个，但是里面是空语句
    Person()
    {
        
    }
    */

    //2、析构函数 进行情理的操作
    //没有返回值也不写void。
    //函数名称与类名相同，在名称前加上~符号。
    //析构函数不可以有参数，因此不可以发生重载。
    //程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次。
    ~Person()
    {
        cout << "Person 析构函数的调用" << endl;
    }
};

//构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现
void test01()
{
    Person p;  //创建对象的时候，自动调用构造函数
               //这个对象p是一个局部变量，是在栈上的数据，test01执行完，释放这个对象
}

int main()
{
    
    //方式一：
    test01();   // 析构释放时机在test01运行完前，test01函数运行完后，里面的对象就被释放了
    

    /*
    方式二：     //创建对象的时候，自动调用构造函数
    Person p;   //只有构造函数，没有析构函数，只有main函数结束完前，对象要释放掉了，才会调用析构函数
    */

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725709914254-a9215cc4-762b-460f-ae15-babebf6c4573.png)

```cpp
// ① 两种分类方式：
// 1、按参数分为：有参构造和无参构造。
// 2、按类型分为：普通构造和拷贝构造。

// ② 三种调用方式：
// 1、括号法
// 2、显示法
// 3、隐式转换法

#include <iostream>
using namespace std;

//1构造函数的分类及调用
//分类
//按照参数分类：无参构造(默认构造) 和 有参构造
class Person
{
public: 
    //构造函数  编译器默认的构造函数是无参的
    Person()
    {
        cout << "Person 无参构造函数的调用" << endl;
    }


    Person(int a)
    {
        age = a;
        cout << "Person 有参构造函数的调用" << endl;
    }

    //拷贝构造函数
    Person( const Person &p)  //用引用的方式传进来，不能改变原来的对象的属性，所以用const        
    {
        // 将传入的人人身上的所有属性，拷贝到我身上
        cout << "Person 拷贝构造函数的调用" << endl;
        age = p.age;
    }

    ~Person()
    {
        cout << "Person 析构函数的调用" << endl;
    }

    int age;
};

//调用
void test01()
{
    /*
    
    //1、括号法
    Person p1;       //默认构造函数调用
    Person p2(10);   //有参构造函数
    Person p3(p2);   //拷贝构造函数

    cout << "p2的年龄为：" << p2.age << endl;
    cout << "p3的年龄为：" << p3.age << endl;

    //注意事项1
    //调用默认构造函数的时候，不要加()。
    //下面这行代码，编译器会认为是一个函数的声明，像void func(),不会认为在创建对象。
    //Person p1();

    */

    /*
    * 
    //2、显示法
    Person p1;  //创建一个对象，这个对象调用的是无参构造
    Person p2 = Person(10); //有参构造  将匿名对象起了一个名称p2
    Person p3 = Person(p2); //创建一个对象，这个对象调用的是拷贝构造

    Person(10); //匿名对象 特点：当前行执行结束后，系统会立即回收匿名对象
    cout << "aaaa" << endl;  //通过打印时机可以得到：test还没结束，就运行析构函数了
    
    //注意事项2
    //不要利用拷贝构造函数 初始化匿名对象  编译器认为 Person(p3) 等价于 Person p3，
    //编译器会认为这是一个对象的声明，而上面已经有一个p3了，Person p3 = Person(p2);因此编译器认为重定义了       
    Person(p3);

    */
    
    //3、隐式转换法
    Person p4 = 10; //相当于 写了 Person p4 = Person(10);  调用有参构造
    Person p5 = p4; //调用拷贝构造

}
int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725709976224-3e370d1c-7116-44c2-b05f-4c1ca1e7516f.png)

```cpp
//C++中拷贝构造函数调用时机通常有三种情况。
//1、使用一个已经创建完毕的对象来初始化一个新对象。
//2、值传递的方式给函数参数传值。
//3、以值方式返回局部对象。

#include <iostream>
using namespace std;

//拷贝构造函数调用时机

//1、使用一个已经创建完毕的对象来初始化一个新对象

//2、值传递的方式给函数参数传值

//3、值方式返回局部对象

class Person
{
public:
    Person()
    {
        cout << "Person 默认构造函数调用" << endl;
    }

    Person(int age)
    {
        m_Age = age;
        cout << "Person 有参构造函数调用" << endl;
    }

    Person(const Person& p)
    {
        m_Age = p.m_Age;
        cout << "Person 拷贝构造函数调用" << endl;
    }

    ~Person()
    {
        cout << "Person 析构函数调用" << endl;
    }

    int m_Age;

};

//1、使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
    Person p1(20);
    Person p2(p1);

    cout << "p2的年龄为：" << p2.m_Age << endl;
}

//2、值传递的方式给函数参数传值
void doWork(Person p)
{

}

void test02()
{
    Person p;
    doWork(p);   //实参传给形参的时候，会调用拷贝构造函数，这个是值传递，是一个临时的副本
                 //拷贝出去的p和原来的p 不是一个p
}

//3、值方式返回局部对象
Person doWork2() //返回值类型为Person对象
{
    Person p1;   //局部对象
    cout << (int*)&p1 << endl;
    return p1;  //以值的方式返回一个拷贝的对象给外部，拷贝出一个对象p1'与原对象p1不一样,调用拷贝构造函数

    //程序运行结束，释放原p1，调用析构函数
}

void test03()
{
    Person p = doWork2(); //这里没有调用拷贝构造函数，直接用p接收拷贝对象p1’
    cout << (int*)&p << endl;

    //程序运行结束，释放拷贝的对象p1',调用析构函数
}

int main()
{
    //test01();	
    //test02();
    test03();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725710039286-da457410-d2d3-4f19-a085-af88d7225e04.png)

```plain
//构造函数调用规则

// ① 默认情况下，C++编译器至少给一个类添加3个函数。
// 1、默认构造函数(无参，函数体为空)
// 2、默认析构函数(无参，函数体为空)
// 3、默认拷贝构造函数，对属性进行值拷贝

// ② 构造函数调用规则如下：
// 1、如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造。
// 2、如果用户定义拷贝函数，C++不会再提供其他构造函数。

// ③ 巧记法，如下图所示，如果定义中间的，上面的就默认不定义了，下面的默认定义。
```

```cpp
#include <iostream>
using namespace std;

//构造函数的调用规则
//1、创建一个类，C+=编译器会给每个类都添加至少3个函数
//默认构造 (空实现)
//析构函数 (空实现)
//拷贝构造 (值拷贝)

class Person
{
public:
    Person()
    {
        cout << "Person 默认构造函数调用" << endl;
    }
    
    Person(int age)
    {
        m_Age = age;
        cout << "Person 有参构造函数调用" << endl;
    }

    Person(const Person & p)
    {
        m_Age = p.m_Age;
        cout << "Person 拷贝构造函数调用" << endl;
    }

    ~Person()
    {
        cout << "Person 析构函数调用" << endl;
    }

    int m_Age;

};

void test01()
{
    Person p;
    p.m_Age = 18;
    
    Person p2(p);

    cout << "p2的年龄：" << p2.m_Age << endl;
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725710182887-18ad6acc-a5a9-4b33-8c6d-88c16f8165b2.png)

```cpp
#include <iostream>
using namespace std;

//构造函数的调用规则
//1、创建一个类，C+=编译器会给每个类都添加至少3个函数
//默认构造 (空实现)
//析构函数 (空实现)
//拷贝构造 (值拷贝)

class Person
{
public:
    Person()
    {
        cout << "Person 默认构造函数调用" << endl;
    }

    Person(int age)
    {
        m_Age = age;
        cout << "Person 有参构造函数调用" << endl;
    }

    //编译器自动提高拷贝构造函数

    ~Person()
    {
        cout << "Person 析构函数调用" << endl;
    }

    int m_Age;

};

void test01()
{
    Person p;
    p.m_Age = 18;

    Person p2(p);  //调用编译器默认的拷贝构造函数会把p的所有属性拷贝过来

    cout << "p2的年龄：" << p2.m_Age << endl;
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725710251756-cc93f191-cb6c-4223-b99c-9e2ac2aab9d7.png)

```cpp
#include <iostream>
using namespace std;

//构造函数的调用规则
//1、创建一个类，C+=编译器会给每个类都添加至少3个函数
//默认构造 (空实现)
//析构函数 (空实现)
//拷贝构造 (值拷贝)

class Person
{
public:

    Person(int age)
    {
        m_Age = age;
        cout << "Person 有参构造函数调用" << endl;
    }

    //编译器自动提高拷贝构造函数

    ~Person()
    {
        cout << "Person 析构函数调用" << endl;
    }

    int m_Age;

};


void test02()
{
    Person p; //如果写了有参构造函数，编译器就不再提供默认构造，依然提供拷贝构造构造
              //由于没有默认构造函数，所以报错

    Person p2(p);
}

int main()
{
    test02();

    system("pause");

    return 0;

}
```

<font style="color:#DF2A3F;">报错！没有默认构造函数</font>

```cpp
#include <iostream>
using namespace std;

//构造函数的调用规则
//1、创建一个类，C+=编译器会给每个类都添加至少3个函数
//默认构造 (空实现)
//析构函数 (空实现)
//拷贝构造 (值拷贝)

class Person
{
public:
    //如果写了拷贝构造函数，编译器就不再提供其他普通构造函数
    Person(const Person& p)
    {
        m_Age = p.m_Age;
        cout << "Person 拷贝构造函数调用" << endl;
    }

    ~Person()
    {
        cout << "Person 析构函数调用" << endl;
    }

    int m_Age;

};

void test01()
{
    Person p;    //没有默认构造函数，报错
    Person(10);  //没有有参构造函数，报错

    Person p2(p);

    cout << "p2的年龄：" << p2.m_Age << endl;
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

<font style="color:#DF2A3F;">报错！没有有参构造函数</font>

```cpp
// ① 浅拷贝：简单的赋值拷贝操作。

// ② 深拷贝：在堆区重新申请空间，进行拷贝操作。

// ③ 浅拷贝，带来的问题就是堆区的内存重复释放。

// ④ 深拷贝，在堆区自己创建一份内存，可以避免堆区的内存重复释放。

#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        cout << "Person的默认构造函数调用" << endl;
    }
    Person(int age,int height)
    {
        m_Age = age;
        m_Height = new int(height);   //把数据创建在堆区，用指针接收new创建的地址
        cout << "Person的有参构造函数调用" << endl;
    }

    //自己实现拷贝函数 解决浅拷贝带来的问题
    Person(const Person& p)
    {
        cout << "Person 拷贝构造函数调用" << endl;
        m_Age = p.m_Age;
        //m_Height = p.m_Height; 编译器默认实现就是这行代码，默认执行的是浅拷贝
                                //浅拷贝带来的问题就是堆区的内存重复释放


        // 深拷贝操作，在堆区自己创建一份内存
        m_Height = new int(*p.m_Height);
    }
    
    ~Person()
    {
        //析构代码，将堆区开辟数据做释放操作
        cout << "Person的析构函数调用" << endl;
        if (m_Height != NULL)
        {
            delete m_Height;    //释放堆区数据

        }
    }
    int m_Age;
    int * m_Height;
};

void test01()
{
    Person p1(18,160);
    
    cout << "p1的年龄为：" << p1.m_Age << "身高为：" << * p1.m_Height << endl; //指针通过解引用获得数据

    Person p2(p1);

    cout << "p2的年龄为：" << p2.m_Age << "身高为：" << * p2.m_Height << endl;

}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725710486357-eeb45621-3e05-47e4-be20-5a316274bdba.png)



### 1.5.友元
```cpp
// ① 生活中你的家有客厅(Public)，有你的卧室(Private)，客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的好闺蜜进去。

// ② 在程序里，有些私有属性，也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术。

// ③ 友元的目的就是让一个函数或者类访问另一个类中私有成员。

// ④ 友元的关键字为 friend。

// ⑤ 友元的三种实现：

// 1、全局函数做友元。
// 2、类做友元。
// 3、成员函数做友元。

#include <iostream>
using namespace std;

//建筑物类
class Buiding
{
    //goodfriend全局函数是Buiding类好朋友，可以访问Buiding中私有成员
    friend void goodfriend(Buiding* buiding);

public:
    Buiding()  //构造函数 赋初值
    {
        m_SittingRoom = "客厅";
        m_BedRoom     = "卧室";
    }

public:
    string m_SittingRoom; //客厅

private:
    string m_BedRoom;
};

//全局函数
void goodfriend(Buiding *buiding)
{
    cout << "好基友全局函数 正在访问：" << buiding->m_SittingRoom << endl;
    cout << "好基友全局函数 正在访问：" << buiding->m_BedRoom     << endl;

}

void test01()
{
    Buiding building;
    goodfriend(&building);
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725707429588-57a790de-ad51-43df-aa32-43292dfe352a.png)



```cpp
#include <iostream>
using namespace std;

//类做友元
class Building; //声明

class GoodGay
{
public:
    GoodGay();

    void visit(); //参观函数 访问Building中的属性

    Building* building;
};

class Building
{
    //GoodGay类是本类的好朋友，可以访问本类的私有成员
    friend class GoodGay;

public:
    Building();

public:
    string m_SittingRoom; //客厅
private:
    string m_BedRoom; //卧室
};

//类外写成员函数，写类名的作用域

//Building构造函数
Building::Building()
{
    m_SittingRoom = "客厅";
    m_BedRoom     = "卧室";
}

//GoodGay构造函数
GoodGay::GoodGay()
{
    //创建建筑物对象
    building = new Building;    //这里会调用Building的构造函数
                                //new是创建什么样的数据类型，就返回什么样的数据类型的指针       
}

void GoodGay::visit()
{
    cout << "好基友类正在访问：" << building->m_SittingRoom << endl;

    cout << "好基友类正在访问：" << building->m_BedRoom << endl;

}

void test01()
{
    GoodGay gg; //创建一个GoodGay的对象，会调用GoodGay构造函数，会创建一个building，然后调用building构造函数      
    gg.visit();
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725707961206-da9036ac-55cc-461e-a11e-27f16f45e971.png)

```cpp
#include <iostream>
using namespace std;

class Building;
class GoodGay
{
public:
    GoodGay();

    void visit();  //让visit函数可以访问Building中私有成员
    void visit2(); //让visit2函数不可以访问Buildinng中私有成员

    Building* building;
};

class Building
{
    //告诉编译器，GoodGay类下的visit成员函数作为本类的好朋友，可以访问私有成员           
    friend void GoodGay::visit();

public:
    Building();

public:
    string m_SittingRoom; //客厅

private:
    string m_BedRoom; //卧室
};

// 类外实现构造函数
Building::Building()
{
    m_SittingRoom = "客厅";
    m_BedRoom     = "卧室";
}

GoodGay::GoodGay()
{
    building = new Building;
}

// 类外实现成员函数
void GoodGay::visit()
{
    cout << "visit 函数正在访问" << building->m_SittingRoom << endl;
    cout << "visit 函数正在访问" << building->m_BedRoom << endl;

}

void GoodGay::visit2()
{
    cout << "visit2 函数正在访问" << building->m_SittingRoom << endl;
    //cout << "visit 函数正在访问" << building->m_BedRoom << endl;

}

void test01()
{
    GoodGay gg;
    gg.visit();
    gg.visit2();
}

int main()
{
    test01();
    
    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708002863-cf3a57bd-c939-4e75-9cf6-677d1470f9ee.png)

### 2.继承
#### 继承简介
① 继承是面向对象的三大特性之一。

② 定义类时，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候，就可以考虑利用继承技术，减少重复代码。



```cpp
//普通实现
#include <iostream>
using namespace std;
#include<string>

//打印输出类
class Java
{
public:
    void header()
    {
        cout << "首页、公开课、登陆、注册...(公共头部)" << endl;
    }
    void footer()
    {
        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
    }
    void left()
    {
        cout << "Java、Python、C++....(公共分类列表)" << endl;
    }
    void content()
    {
        cout << "Java学科视频" << endl;
    }
};

class Python
{
public:
    void header()
    {
        cout << "首页、公开课、登陆、注册...(公共头部)" << endl;
    }
    void footer()
    {
        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
    }
    void left()
    {
        cout << "Java、Python、C++....(公共分类列表)" << endl;
    }
    void content()
    {
        cout << "Python学科视频" << endl;
    }
};

class CPP
{
public:
    void header()
    {
        cout << "首页、公开课、登陆、注册...(公共头部)" << endl;
    }
    void footer()
    {
        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
    }
    void left()
    {
        cout << "Java、Python、C++....(公共分类列表)" << endl;
    }
    void content()
    {
        cout << "C++学科视频" << endl;
    }
};

void test01()
{
    cout << "Java下载视频页面如下：" << endl;
    Java ja;
    ja.header();
    ja.footer();
    ja.left();
    ja.content();

    cout << "........................" << endl;
    cout << "Python下载视频页面如下：" << endl;
    Python py;
    py.header();
    py.footer();
    py.left();
    py.content();

    cout << "........................" << endl;
    cout << "C++下载视频页面如下：" << endl;
    CPP cpp;
    cpp.header();
    cpp.footer();
    cpp.left();
    cpp.content();
}

int main()
{
    test01();
    
    system("pause");

    return 0;

}

```

这是一个只用一般的类与成员函数方法写的模拟同一个网页页面各种选项类别（如java，python，C++)的程序，会发现有很多重复代码，显得比较繁琐。

```cpp
/*
继承简介
① 继承是面向对象的三大特性之一。

② 定义类时，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候，就可以考虑利用继承技术，减少重复代码。
*/

//继承实现
#include <iostream>
using namespace std;
#include<string>

//打印输出类
class BasePage
{
public:
void header()
{
    cout << "首页、公开课、登陆、注册...(公共头部)" << endl;
}
void footer()
{
    cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
}
void left()
{
    cout << "Java、Python、C++....(公共分类列表)" << endl;
}
};

// 继承的好处：减少重复代码
// 语法：class 子类：继承方式 父类
// 子类 也称为 派生类
// 父类 也称为 基类

//Java页面
class Java:public BasePage   //继承了BasePage，把BasePage里面的内容全部拿到手了
{
public:
void content()
{
    cout << "Java学科视频" << endl;
}
};

//Python页面
class Python :public BasePage   //继承了BasePage，把BasePage里面的内容全部拿到手了
{
public:
void content()
{
    cout << "Python学科视频" << endl;
}
};

//C++页面
class CPP :public BasePage   //继承了BasePage，把BasePage里面的内容全部拿到手了
{
public:
void content()
{
    cout << "CPP学科视频" << endl;
}
};

void test01()
{
    cout << "Java下载视频页面如下：" << endl;
    Java ja;
    ja.header();
    ja.footer();
    ja.left();
    ja.content();

    cout << "........................" << endl;
    cout << "Python下载视频页面如下：" << endl;
    Python py;
    py.header();
    py.footer();
    py.left();
    py.content();

    cout << "........................" << endl;
    cout << "C++下载视频页面如下：" << endl;
    CPP cpp;
    cpp.header();
    cpp.footer();
    cpp.left();
    cpp.content();
}

int main()
{
    test01();
    
    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725704313044-8864eab5-af1b-4afd-be94-dd0baf44d9eb.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725704630177-0e2dd0ca-2646-41a3-b848-89d7ed66a761.png)![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725704644126-b176642f-66ec-4af6-8437-69199339b03c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725704719474-fd36d137-9499-484a-9fd8-6b0ad200cdb5.png)![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725704680852-36226579-0467-429f-bb50-b48c645bb9b0.png)

#### 继承语法
![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725705436020-047cdc4b-a8ed-468d-9471-43165af22b39.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725705404308-be19ab2e-a54b-40be-8c0b-6cd1bc1f6db2.png)

```cpp

/**
① 继承的语法：class 子类：继承方式 父类

② 继承方式一共有三种：

公共继承
保护继承
私有继承
③ 不同的继承方式，父类中的变量被继承后，权限相应的得到了改变
**/

#include <iostream>
using namespace std;
#include<string>

//打印输出类
class Base1
{
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;
};

//公共继承
class Son1:public Base1
{
public:
    void func()
    {
        m_A = 10; //父类中的公共权限成员 到子类中依然是公共权限
        m_B = 10; //父类中的保护权限成员 到子类中依然是保护权限
        //m_C = 10; //父类中的私有权限成员 子类访问不到

    }
};

void test01()
{
    Son1 s1;
    s1.m_A = 100;  //公共权限，类内能访问，类外也能访问
    //s1.m_B = 100;  //保护权限，类内能访问，类外不能访问
}

//保护继承
class Son2:protected Base1
{
public:
    void func()
    {
        m_A = 10; //父类中的公共权限成员 到子类中变为保护权限
        m_B = 10; //父类中的保护权限成员 到子类中依然是保护权限
        //m_C = 10; //父类中的私有权限成员 子类访问不到

    }
};


void test02()
{
    Son2 s2;
    //s2.m_A = 100;  //保护权限，类内能访问，类外不能访问
    //s2.m_B = 100;  //保护权限，类内能访问，类外不能访问
}

//私有继承
class Son3:private Base1
{
public:
    void func()
    {
        m_A = 10; //父类中的公共权限成员 到子类中变为私有权限
        m_B = 10; //父类中的保护权限成员 到子类中变为私有权限
        //m_C = 10; //父类中的私有权限成员 子类访问不到

    }
};

void test03()
{
    Son3 s3;
    //s3.m_A = 100;  //私有权限，类内能访问，类外不能访问
    //s3.m_B = 100;  //私有权限，类内能访问，类外不能访问
}

int main()
{

    system("pause");

    return 0;

}
```

#### 查询继承对象所占内存
```cpp
#include <iostream>
using namespace std;
#include<string>

//继承中的对象模型

class Base
{
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;
};


//公共继承
class Son:public Base
{
    int m_D; 
};

//利用开发人员命令提示工具查看对象模型
//跳转盘符→F:
//跳转文件路径→cd 具体路径下
//查看命令
//cl /d1 reportSingleClassLayout查看的类名 "文件名"     //ps:文件名可以写个部分tab补全

void test01()
{
    //父类中所有非静态成员属性都会被子类继承下去
    //父类中私有成员属性 是被编译器给隐藏了，因此是访问不到，但是确实被继承下去了
    cout << "size of Son =" << sizeof(Son) << endl;  //16个字节，父类3个int一共12个字节，子类1个int占4个字节                        
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725704998240-97206488-bc3d-4a2b-b8d6-3f7f38341061.png)

使用这个工具可查看继承对象内存分布。

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725705327476-710b1eb9-5ba0-4adf-886e-e3aae12288eb.png)

<font style="color:#DF2A3F;">子类继承父类的私有权限无法访问，但是确实继承了，只是被编译器隐藏了。</font>



#### 构造与析构顺序
子类继承父类后，当创建子类对象，也会调用父类的构造函数

<font style="color:#8CCF17;">问题：父类和子类的构造和析构顺序是谁先谁后？</font>

答：<font style="color:#DF2A3F;">继承中，先调用父类构造函数，再调用子类构造函数，析构顺序则与构造顺序相反，先调用子类析构函数，再调用父类析构函数。</font>

```cpp
/**
继承构造和析构顺序
① 继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造顺序相反，先调用子类析构函数，再调用父类析构函数。
**/

#include <iostream>
using namespace std;
#include<string>

//继承中的构造和析构顺序
//父类
class Base
{
public:
    Base()
    {
        cout << "Base构造函数！" << endl;
    }

    ~Base()
    {
        cout << "Base析构函数！" << endl;
    }
};


//子类继承
class Son:public Base
{
public:
    Son()
    {
        cout << "Son构造函数！" << endl;
    }

    ~Son()
    {
        cout << "Son析构函数！" << endl;
    }
};

void test01()
{
    //Base b;  
    //创建父类对象只有父类的构造函数、析构函数

    //继承中的构造和析构顺序如下：
    //先构造父类、再构造子类，析构的顺序与构造的顺序相反
    Son s;
}


int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725705727107-786b30a3-5c83-4690-999f-d78e9be5f1b6.png)

#### 同名成员处理
![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725705833912-42ed9b8a-1a2b-4355-ac79-5d0b2f231c26.png)

答：<font style="color:#DF2A3F;">当子类与父类拥有同名的成员函数，子类会隐藏父类中所有同名成员函数(例如有参、无参)，加作用域才可以访问到父类中同名函数。</font>

```cpp

/**
① 子类对象可以直接访问到子类中同名成员。

② 子类对象加作用域可以访问到父类同名成员。

③ 当子类与父类拥有同名的成员函数，子类会隐藏父类中所有同名成员函数(有参、无参)，加作用域才可以访问到父类中同名函数。
**/

#include <iostream>
using namespace std;
#include<string>


//继承中同名成员处理

class Base
{
public:
    Base()
    {
        m_A = 100;
    }
    int m_A;
    
    void func()
    {
        cout << "Base 中 func()调用" << endl;
    }

    void func(int a)
    {
        cout << "Base 中 func(int a)调用" << endl;
    }
};

class Son:public Base
{
public:
    Son()
    {
        m_A = 200;
    }

    void func()
    {
        cout << "Son 中 func()调用" << endl;
    }

    int m_A;
};

//同名成员属性处理方式
void test01()
{
    Son s;
    cout << "Son 下的 m_A=" << s.m_A << endl;
    //如果通过子类对象访问到父类中同名成员，需要加作用域
    cout << "Base 下的 m_A=" << s.Base::m_A << endl;  

}

//同名成员函数处理方式
void test02()
{
    Son s;
    s.func(); //直接调用 调用时子类中的同名成员

    //调用父类中同名成员函数
    s.Base::func();

    //如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数
    //如果想访问到父类中被隐藏的同名成员函数，需要加作用域
    s.Base::func(100);
}

//同名成员函数处理
int main()
{
    test01();
    test02();
    
    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725705977531-650951dc-7976-4a27-8313-c9c1f039967f.png)



![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706113888-fb192cc1-0cbb-4cd4-b725-5db5cdcb7374.png)

同名静态成员处理方式和非静态成员处理方式一样，只不过有两种访问方式（通过对象和通过类名）。

```cpp
/**

同名静态成员处理
① 静态成员和非静态成员出现同名，处理方式一致：

1.访问子类同名成员，直接访问
2.访问父类同名成员，需要加作用域

② 加上static关键字后，成员发生变化，成员变成静态成员。

③ 静态成员变量特点：

1.所有对象都共享同一份数据。
2.编译阶段就分配内存。
3.类内声明，类外初始化。

④ 静态成员函数特点：

1.只能访问静态成员变量，不能访问非静态成员变量。
2.所有对象都共享同一份函数实例。

**/

#include <iostream>
using namespace std;

//继承中同名静态成员处理方式
class Base
{
public:
    
    static int m_A;  //静态成员类内声明，类外初始化

    static void func()
    {
        cout << "Base 中 static func()" << endl;
    }

    static void func(int a)
    {
        cout << "Base 中 static func(int a)" << endl;
    }
};

int Base::m_A=100;

class Son:public Base
{
public:

    static int m_A;

    static void func()
    {
        cout << "Son 中 static func()" << endl;
    }
};

int Son::m_A = 200;

//同名静态成员属性的访问
void test01()
{
    //1、通过对象访问
    cout << "通过对象访问：" << endl;
    Son s;
    cout << "Son 下的 m_A = " << s.m_A << endl;
    cout << "Base 下的 m_A = " << s.Base::m_A << endl;

    //2、通过类名访问
    cout << "通过类名访问：" << endl;
    cout << "Son 下的 m_A = "<< Son::m_A << endl;
    //第一个::代表通过类名方式访问  第二个::代表访问父类作用域
    cout << "Base 下的 m_A= "<< Son::Base::m_A << endl;  
}

//同名静态成员函数的访问
void test02()
{
    //1、通过对象访问
    cout << "通过对象访问：" << endl;
    Son s;
    s.func();
    s.Base::func();

    //2、通过类名访问
    cout << "通过类名访问：" << endl;
    Son::func();
    Son::Base::func();

    //子类出现和父类同名静态成员函数，也会隐藏掉父类中所有同名成员函数
    //如何想访问父类中被隐藏同名成员，需要加作用域
    Son::Base::func(100);
}

//同名成员函数处理
int main()
{
    test01();
    test02();
    
    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706211274-2ece7d7c-1796-473e-852e-36b35796ec95.png)

#### 多继承语法
![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706282760-5c860c44-1ff6-4294-a5e8-b8ba9443972d.png)

```cpp
/**
多继承语法
① C++允许一个类继承多个类。

② 语法：class 子类：继承方式 父类1，继承方式 父类2，.....

③ 多继承可能会引发父类中有同名成员出现，需要加作用域区分。

④ C++实际开发中不建议用多继承。
**/

#include <iostream>
using namespace std;

class Base1
{
public:
    
    Base1()
    {
        m_A = 100;
    }
    
    int m_A;

};

class Base2
{
public:

    Base2()
    {
        m_A = 200;
    }

    int m_A;

};

//子类  需要继承Base1和Base2
//语法：class 子类：继承方式 父类1，继承方式 父类2，.....
class Son:public Base1,public Base2
{
public:

    Son()
    {
        m_C = 300;
        m_D = 400;
    }

    int m_C;
    int m_D;
};

void test01()
{
    Son s;

    cout << "sizeof(Son):" << sizeof(s) << endl;
    //当父类中出现同名成员，需要加作用域区分
    cout << "Base1::m_A = " << s.Base1::m_A << endl;
    cout << "Base2::m_A = " << s.Base2::m_A << endl;

}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706368543-5b358e30-cf19-4e51-ad60-ae637146de1a.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706435029-6456d6d1-0385-4609-9472-1386f876de12.png)



![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706479098-5f8cc05b-1091-4a53-93da-5d139cf118ce.png)

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706490567-73095e83-62e4-413c-b535-00f8221a5b7f.png)

羊驼继承两个父类两份相同的数据，但是只需要一份就可以了，所以浪费了资源。

```cpp
/*
 菱形继承简介
① 菱形继承概念：

1.两个派生类继承同一个基类
2.又有某个类同时继承两个派生类
3.这种继承被称为菱形继承

② 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据是，就会产生二义性。

③ 草泥马继承自动物的数据继承了两份，其实我们应当清楚，这份数据我们只需要一份就可以。

④ 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义。

⑤ 利用虚继承可以解决菱形继承问题。
*/

//菱形继承普通方式
#include <iostream>
using namespace std;

//动物类
class Animal
{
public:
    int m_Age;
};

//羊类
class Sheep:public Animal{};

//驼类
class Tuo:public Animal{};

//羊驼类
class SheepTuo:public Sheep,public Tuo{};

void test01()
{
    SheepTuo st;

    st.Sheep::m_Age = 18;
    st.Tuo::m_Age = 28;

    //当出现菱形继承，两个父类拥有相同数据，需要加以作用域区分
    cout << "st.Sheep::m_Age="<< st.Sheep::m_Age << endl;
    cout << "st.Tuo::m_Age=" << st.Tuo::m_Age << endl;

    //这份数据我们知道 只有一份就可以，菱形继承导致数据有两份，资源浪费
}

int main()
{
    test01();

    system("pause");

    return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706528176-42113aa7-637b-402a-9e3f-bd1ed671c625.png)

#### 虚继承
可以添加关键字virtual变成虚继承，解决菱形继承中子类继承两份相同的属性数据导致的资源浪费问题。

```cpp
#include <iostream>
using namespace std;

//动物类
class Animal
{
public:
    int m_Age;
};

//利用虚继承 解决菱形继承的问题
//继承之前 加上关键字 virtual 变成 虚继承
//虚继承后，最大的Animal类 称为 虚基类

//羊类
class Sheep:virtual public Animal{};

//驼类
class Tuo:virtual public Animal{};

//羊驼类
class SheepTuo:public Sheep,public Tuo{};

void test01()
{
    SheepTuo st;

    st.Sheep::m_Age = 18;
    st.Tuo::m_Age = 28;

    //当出现菱形继承，两个父类拥有相同数据，需要加以作用域区分
    cout << "st.Sheep::m_Age="<< st.Sheep::m_Age << endl;
    cout << "st.Tuo::m_Age=" << st.Tuo::m_Age << endl;

    //虚继承，多产生一种输出方式(因为上面两个是同一份数据，所以可以不加作用域来区分了)
    cout << "st.m_Age=" << st.m_Age << endl;
}

int main()
{
    test01();

    system("pause");

    return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725706670333-fe4f3e9b-3ad6-4069-9c90-b2a926604a59.png)



![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725707116248-6eaf214c-71fb-4ad9-92e8-d3619f4daf0e.png)



### 3.多态
```cpp
/*
① 多态是C++面向对象三大特性之一。

② 多态分为两类：

静态多态：函数重载和运算符重载属于静态多态，复用函数名。
动态多态：派生类和虚函数实现运行时多态。
③ 静态多态和动态多态区别：

静态多态的函数地址早绑定，编译阶段确定函数地址。
动态多态的函数地址晚绑定，运行阶段确定函数地址。
④ 多态满足条件：

有继承关系
子类重写父类中的虚函数
⑤ 多态使用条件：

父类指针或引用指向子类对象
⑥ 重写：函数返回值类型、函数名、参数列表都完全一致称为重写。
*/

// 地址早绑定
#include <iostream>
using namespace std;

//多态

//动物类
class Animal
{
public:
    void speak()
    {
        cout << "动物在说话" << endl;
    }
};

//猫类
class Cat:public Animal
{
public:
    void speak()
    {
        cout << "小猫在说话" << endl;
    }
};

//执行说话的函数
//地址早绑定 在编译阶段确定函数地址
void doSpeak(Animal &animal)  // Animal & animal = cat
{
    animal.speak();
}

void test01()
{
    Cat cat;
    doSpeak(cat);
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708187308-6bfe9b3b-02cf-4646-8353-80513fef7620.png)

```cpp
//地址晚绑定虚函数
#include <iostream>
using namespace std;

//多态

//动物类
class Animal
{
public:                   //如果是虚函数，那么类里面存了一个指针，类占4个字节
    virtual void speak()  //如果是非静态成员函数void speak()，那么函数不在类上，空类占1个字节空间   
    {
        cout << "动物在说话" << endl;
    }
};

//猫类
class Cat:public Animal
{
public: 
    //重写 函数返回值类型、函数名、参数列表都完全相同才叫重写
    void speak()   //子类virtual可写可不写，也可以写 virtual void speak()
    {
        cout << "小猫在说话" << endl;
    }
};

//狗类
class Dog:public Animal
{
public:
    virtual void speak()
    {
        cout << "小狗在说话" << endl;
    }
};

//执行说话的函数
//地址早绑定 在编译阶段确定函数地址
//如果想执行让猫说话，那么这个函数就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定

//动态多态满足条件
//1、有继承关系
//2、子类重写父类的虚函数

//动态多态使用
//父类的引用或指针指向子类对象

void doSpeak(Animal &animal)  // Animal & animal = cat
{
    animal.speak();
}

void test01()
{
    Cat cat;
    doSpeak(cat);

    Dog dog;
    doSpeak(dog);
}

void test02()
{
    cout << "sizeof Animal = " << sizeof(Animal) << endl;
}

int main()
{
    test01();
    test02();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708259063-f84fb94c-9f7d-4fe1-af2e-c409c2e8e602.png)

```cpp
/*
多态案例一-计算器类
    案例描述:
        分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类
     多态的优点：
        （1）代码组织结构清晰
        （2）可读性强
        （3）利于前期和后期的扩展以及维护
*/


#include <iostream>
using namespace std;
#include<string>

/**
//普通方法实现多态

class Calculator
{
public:
    int getResult(string oper)
    {
        if (oper == "+")
        {
            return m_Num1 + m_Num2;
        }
        else if (oper == "-")
        {
            return m_Num1 - m_Num2;
        }
        else if (oper == "*")
        {
            return m_Num1 * m_Num2;
        }
        //如果想扩展新的功能，需要修改源码
        //在真的开发中 提倡 开闭原则
        //开闭原则：对扩展进行开发，对修改进行关闭
    }
    int m_Num1; //操作数1
    int m_Num2; //操作数2
};

void test01()
{
    //创建计算器对象
    Calculator c;
    c.m_Num1 = 10;
    c.m_Num2 = 10;

    cout << c.m_Num1 << "+" << c.m_Num2 << "=" << c.getResult("+") << endl;

    cout << c.m_Num1 << "-" << c.m_Num2 << "=" << c.getResult("-") << endl;

    cout << c.m_Num1 << "*" << c.m_Num2 << "=" << c.getResult("*") << endl;
    
}

int main()
{
    test01();

    system("pause");

    return 0;

}
**/

//多态

class AbstractCalculator
{
public:
    virtual int getResult()
    {
        return 0;
    }
    int m_Num1;
    int m_Num2;

};

//加法计算器类
class AddCalculator : public AbstractCalculator
{
public:
    int getResult()
    {
        return m_Num1 + m_Num2;
    }
};

//减法计算器类
class SubCalculator : public AbstractCalculator
{
public:
    int getResult()
    {
        return m_Num1 - m_Num2;
    }
};

//乘法计算器类
class MulCalculator : public AbstractCalculator
{
public:
    int getResult()
    {
        return m_Num1 * m_Num2;
    }
};

void test02()
{
    //多态使用条件
    //父类指针或者引用指向子类对象
    AbstractCalculator* abc = new AddCalculator;  //这里用的是父类指针指向子类对象
    abc->m_Num1 = 100;
    abc->m_Num2 = 200;

    cout << abc->m_Num1 << "+" << abc->m_Num2 << "=" << abc->getResult() << endl;
    //用完后记得销毁
    delete abc;

    //减法运算
    abc = new SubCalculator;  //指针并没有释放
    abc->m_Num1 = 100;
    abc->m_Num2 = 200;

    cout << abc->m_Num1 << "-" << abc->m_Num2 << "=" << abc->getResult() << endl;
    //用完后记得销毁
    delete abc;

    //乘法运算
    abc = new MulCalculator;  //指针并没有释放
    abc->m_Num1 = 100;
    abc->m_Num2 = 200;

    cout << abc->m_Num1 << "*" << abc->m_Num2 << "=" << abc->getResult() << endl;
    //用完后记得销毁
    delete abc;
}

int main()
{
    test02();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708342676-729fc5fb-c8cb-496c-abd7-9cdbbce98d0a.png)

```cpp
/*
① 在多态中，通常父类中虚函数的实现时毫无意义的，主要都是调用子类重写的内容。因此，可以将虚函数改为纯虚函数。

② 纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0；

③ 当类中有了纯虚函数，这个类也称为抽象类。

④ 抽象类特点：

1.无法实例化对象
2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类。
*/

#include <iostream>
using namespace std;

//纯虚函数和抽象类
class Base
{
public:
    //纯虚函数
    //只要有一个纯虚函数，这个类称为抽象类
    //抽象类特点：
    //1、无法实例化对象
    //2、抽象类的子类 必须要重写父类中的纯虚函数，否则也属于抽象类
    virtual void func() = 0;
};

class Son : public Base
{
public:
    virtual void func()
    {
        cout << "func函数调用" << endl;
     }
};
void test01()
{
    //Base b;   //抽象类是无法实例化对象
    //new Base; //抽象类是无法实例化对象

    //Son s; //子类中必须重写父类中的纯虚函数，否则无法实例化对象

    Base* base = new Son;
    base->func();
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708409829-7ae2b6d3-7f61-4ec9-bd3c-fc19124e7a61.png)

```cpp
/*
① 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码。

② 解决方式：将父类中的析构函数改为虚析构或者纯虚析构。

③ 虚析构和纯虚析构共性：

1.可以解决父类指针释放子类对象
2.都需要有具体的函数实现

④ 虚析构语法：virtual.类名(){}

⑤ 纯虚析构语法：

1.virtual~类名 = 0；
2.类名::~类名(){}

① 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象。

② 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。

③ 拥有纯虚析构函数的类也属于抽象类。
*/

#include <iostream>
using namespace std;
#include<string>

//纯虚函数和纯虚机构
class Animal 
{
public:
    Animal()
    {
        cout << "Animal构造函数调用" << endl;
    }

    //纯虚函数
    virtual void speak() = 0;

    /*
    //利用虚析构可以解决，父类指针释放子类对象时不干净的问题
    virtual ~Animal()
    {
        cout << "Animal析构函数调用" << endl;
    }
    */

    //纯虚析构 需要声明也需要实现
    //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象
    virtual ~Animal() = 0;
    
};

Animal::~Animal()
{
    cout << "Animal纯虚析构函数调用" << endl;
}


class Cat : public Animal
{
public:
    Cat(string name)
    {
        cout << "Cat构造函数调用" << endl;
        m_Name = new string(name);
    }

    virtual void speak()
    {
        cout << *m_Name << "小猫在说话" << endl;
     }

    ~Cat()
    {
        if (m_Name != NULL)
        {
            cout << "Cat析构函数调用" << endl;
            delete m_Name;
            m_Name = NULL;
        }
    }

    string* m_Name;
};

void test01()
{
    Animal* animal = new Cat("Tom");
    animal->speak();
    //父类指针在析构时候，不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄露
    delete animal;
}

int main()
{
    test01();

    system("pause");

    return 0;
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708475003-11098b40-4b67-4afc-b631-948226ff8ad3.png)

```cpp
#include <iostream>
using namespace std;

class AbstractDring
{
public:
    //煮水
    virtual void Boil() = 0;

    //冲泡
    virtual void Brew() = 0;

    //倒入杯中
    virtual void PourInCup() = 0;

    //加入辅料
    virtual void PutSomething() = 0;

    //制作饮品
    void makeDrink()
    {
        Boil();
        Brew();
        PourInCup();
        PutSomething();
    }

};

//制作咖啡
class Coffee :public AbstractDring
{
public:
    //煮水
    virtual void Boil()
    {
        cout << "煮农夫山泉" << endl;
    }

    //冲泡
    virtual void Brew()
    {
        cout << "冲泡咖啡" << endl;
    }

    //倒入杯中
    virtual void PourInCup()
    {
        cout << "倒入杯中" << endl;
    }

    //加入辅料
    virtual void PutSomething()
    {
        cout << "加入糖和牛奶" << endl;
    }
};

//制作茶叶
class Tea :public AbstractDring
{
public:
    //煮水
    virtual void Boil()
    {
        cout << "煮茶叶" << endl;
    }

    //冲泡
    virtual void Brew()
    {
        cout << "冲泡茶叶" << endl;
    }

    //倒入杯中
    virtual void PourInCup()
    {
        cout << "倒入杯中" << endl;
    }

    //加入辅料
    virtual void PutSomething()
    {
        cout << "加入枸杞" << endl;
    }
};

//制作函数
void doWork(AbstractDring* abs)
{
    abs->makeDrink();
    delete abs;  //释放
}

void test01()
{
    //制作咖啡
    doWork(new Coffee);
    cout << "----------------" << endl;
    doWork(new Tea);
}

int main()
{
    test01();

    system("pause");

    return 0;

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/39216292/1725708540929-30103880-1a24-47e0-8edc-af5ba3fcff8a.png)



